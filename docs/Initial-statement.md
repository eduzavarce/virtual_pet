# Virtual pet Full stack app with microservices

# Statement:

# Level 1

### Description of the Virtual Pets Application

The Virtual Pets Application allows users to care for and nurture their own virtual pets. It offers the following functionalities:

Register:

Allows new users to register in the application by creating a username and password.

Login:

Allows existing users to log in to the application with their username and password to obtain a JWT token.

Create:

Allows users to create new virtual pets to care for and nurture. They can choose from a variety of creatures, from dragons to unicorns, and even aliens. Then, they can customize the color, name, and unique characteristics of their pet.

Read:

Displays all existing virtual pets in a vibrant and colorful virtual environment. Users can interact with their pets, see their mood, energy level, and needs.

Update:

Allows users to care for and customize their virtual pets. They can feed them, play with them, buy fun accessories, and change their virtual environment to keep them happy and healthy.

Delete:

Allows users to retire virtual pets they no longer wish to care for. Upon confirming the deletion, the pet disappears from their virtual environment, but they can create a new one at any time.

### Implementation of ROLES

The implementation of ROLES allows differentiating functionalities and permissions between normal users and administrators:

User (ROLE_USER): Has access only to their own virtual pets to view, update, and delete.

Admin (ROLE_ADMIN): Has access to all virtual pets in the system to view, update, and delete, regardless of the owner.

Recommendation:

Implementation of Authorization Middleware:

It is recommended to implement an authorization middleware. This middleware will be responsible for verifying the permissions of the authenticated user before allowing access to protected resources.

The authorization middleware must be designed to validate the user's JWT token and verify that the role associated with the user allows the requested action. For example, normal users should have access only to their own virtual pets for reading, updating, and deleting, while administrators should have full access to all pets in the system, regardless of the owner.

Implementing this middleware not only improves application security by restricting role-based access but also ensures that critical data management operations are executed only by authorized users according to their assigned privileges.

Important Note:

The success of this challenge will be measured primarily on the understanding demonstrated by students about the process of using AI to generate the frontend of an application and the ability to analyze and adjust the generated code. The goal is not to create a functional application, but to learn and understand the process of AI-assisted frontend generation. However, the security back-end part must function correctly.

### Recommendations

Selecting the Right AI:

Step 1: Research the different AI options available (such as ChatGPT, DALLÂ·E, Gemini) and select the one that best suits your needs for generating the frontend, images, and connection with the backend.

Step 2: Consider ease of use, quality of responses, and compatibility with the project.

Interacting Effectively with AI:

Step 1: Formulate clear and specific questions to the AI to get accurate and useful answers.

Step 2: Perform multiple iterations and adjustments to questions to improve the quality of responses.

Step 3: Keep a record of all interactions with the AI to facilitate the presentation.

Understanding Generated Code:

Step 1: Take time to read and understand the code generated by the AI. Identify the different parts and how they integrate.

Step 2: Conduct tests and debugging to ensure the code works as expected.

Step 3: Don't hesitate to ask for additional clarification from the AI if you find parts of the code that you don't understand.

Making Adjustments and Customizations:

Step 1: Adjust the generated code to adapt it to the specific requirements of the project.

Step 2: Add improvements or customizations that you consider necessary to enhance the functionality or aesthetics of the application.

Connecting the Frontend with the Backend:

Step 1: Ensure that the backend endpoints are correctly defined and documented.

Step 2: Configure API calls in the frontend to communicate with the backend and handle responses appropriately.

Step 3: Conduct thorough testing to verify that the communication between the frontend and backend works correctly.

Creating and Testing the Project Step by Step:

Step 1: Start by creating and testing small parts of the project. For example, start by generating a simple component with the AI and test it.

Step 2: Gradually integrate more functionalities, testing at each step to ensure everything works correctly before continuing.

Step 3: Document any problems you encounter and how you solved them, as this information will be valuable for the presentation.

Preparing a Clear and Organized Presentation:

Step 1: Structure the presentation logically, following the points to be presented (AI selection, interactions with the AI, code analysis, frontend-backend connection, reflections).

Step 2: Use visual slides to support your presentation. Include code examples, screenshots, and diagrams when relevant.

Step 3: Practice your presentation to ensure it is fluid and understandable for the audience.

Reflecting on the Learning Process:

Step 1: Identify the most interesting or challenging aspects of the project and reflect on them.

Step 2: Think about the skills and knowledge you've acquired through this experience.

Step 3: Prepare a section of the presentation to share your reflections and conclusions with your peers.

Additional Tips:

Time management: Plan and manage your time effectively to complete all tasks on time. Don't leave everything for the last minute.

Additional resources: Don't hesitate to look for additional resources, such as online tutorials, developer forums, and official documentation, to resolve doubts and improve your understanding of the project.

Example:-> [https://chatgpt.com/share/b271f7ef-f5fd-4a32-84a8-d2da25bd514f](https://www.notion.so/b271f7eff5fd4a3284a8d2da25bd514f?pvs=21)

### Level 2

### Logging Implementation

Task: Integrate a logging system to improve application monitoring and debugging.

Details: A logging framework such as Log4j or SLF4J will be integrated into the API to record important events and errors. This will facilitate tracking application activity and problem resolution.

Steps:

1. Installation and Configuration of the Logging Framework:Install and configure Log4j or SLF4J in the project.
2. Logging Configuration:Define logging levels (INFO, DEBUG, WARN, ERROR).Configure logging output (files, console, external monitoring systems).
3. Integration of Logging in the API:Add logging records at key points in the API, such as incoming requests, responses, critical processes, and errors.Use different logging levels according to the importance of the event.
4. Testing and Validation:Conduct tests to ensure that logging records are generated correctly and contain the expected information.Verify that the logs help identify and resolve problems.

### Cache Implementation:

Task: Integrate a cache system to improve application performance.

Details: A cache system will be added to store frequently accessed data, such as the current state of virtual pets and users' customized configurations. This will help reduce response time and optimize the user experience.

These difficulty levels allow for a natural progression from basic implementation of functionalities to performance improvement through automated testing and cache implementation, addressing crucial aspects of web application development.

### Level 3

### Integration Tests

Task: Implement integration tests for the application

Details: Integration tests ensure that all components of a product work together correctly.

Their main objective is to ensure that there are no communication problems or information transfer issues between components.

## Strategy:

### Full-Stack Microservices Architecture Strategy

### 1. Overall Architecture

We will implement a comprehensive microservices architecture for the Virtual Pet application using Spring Cloud for backend services and ReactJS for the frontend. This approach will provide scalability, resilience, and maintainability.

### 2. Core Infrastructure Services

- **API Gateway (Spring Cloud Gateway)**: Central entry point for all client requests, handling routing, filtering, and load balancing.
- **Discovery Service (Eureka)**: Service registry allowing microservices to locate and communicate with each other dynamically.
- **Configuration Service (Spring Cloud Config)**: Centralized configuration management for all microservices, supporting environment-specific configurations.

### 3. Business Domain Microservices

- **Keycloak Integration**: External identity and access management solution that handles:
  - User authentication and authorization
  - OAuth2/OpenID Connect integration for social login options
  - Role-based access control implementation
- **User Service**: Handles user-related business logic:
  - User profile management
  - User preferences and settings
  - User data management and validation
- **Pet Service**: Core service managing:
    - Pet creation, customization, and management
    - Pet status updates and interactions
    - Pet lifecycle events
- **Payment Service**: Integration with Stripe for:
    - Processing payments for premium features
    - Managing subscriptions
    - Handling payment history and receipts
- **Backoffice Service**: Administrative functionality for:
    - User management
    - System configuration
    - Reporting and analytics

### 4. Observability Infrastructure

- **Grafana Service**: Comprehensive monitoring solution including:
    - Centralized logging with ELK stack (Elasticsearch, Logstash, Kibana)
    - Metrics collection with Prometheus
    - Custom dashboards for system health monitoring
    - Alerting mechanisms for critical issues

### 5. Frontend Architecture

- **ReactJS Application**:
    - Component-based UI architecture
    - Redux for state management
    - Responsive design for multiple device support
    - Integration with backend services via API Gateway

### 6. Data Management Strategy

- **Database per Service**: Each microservice will maintain its own database to ensure loose coupling
- **Cache Implementation**: Redis for caching frequently accessed data
- **Event-Driven Communication**: Using Kafka or RabbitMQ for asynchronous communication between services

### 7. Security Implementation

- **API Security**: JWT-based authentication and authorization
- **Data Encryption**: Sensitive data encryption at rest and in transit
- **Rate Limiting**: Protection against DDoS attacks
- **Regular Security Audits**: Automated vulnerability scanning

### 8. DevOps & Deployment Strategy

- **CI/CD Pipeline**: Automated testing and deployment with Jenkins or GitHub Actions
- **Containerization**: Docker containers for all services
- **Orchestration**: Kubernetes for container orchestration
- **Environment Parity**: Consistent configurations across development, testing, and production

### 9. Implementation Phases

- **Phase 1**: Core infrastructure setup (API Gateway, Discovery, Config)
- **Phase 2**: Authentication and Pet services implementation
- **Phase 3**: Payment integration and Backoffice service
- **Phase 4**: Monitoring infrastructure and frontend development
- **Phase 5**: Integration testing, performance optimization, and security auditing

### 10. Testing Strategy

- **Unit Testing**: Service and component level testing
- **Integration Testing**: Testing service interactions
- **End-to-End Testing**: Testing complete user flows
- **Performance Testing**: Load and stress testing
- **Security Testing**: Vulnerability assessments

This comprehensive strategy provides a solid foundation for developing our Virtual Pet application with a modern microservices architecture that ensures scalability, maintainability, and resilience.

## User stories